Our tests expect the API to find and return a `CashCard` with `id` of `99`. However, we just removed the hard-coded `CashCard` data and replaced it with a call to `cashCardRepository.findById`.

Now our application is crashing, complaining about a missing database table named `CASH_CARD`:

```shell
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "CASH_CARD" not found (this database is empty);
```

We need to help Spring Data configure the database and load some sample data, such as our friend, `CashCard` 99.

Spring Data and H2 can automatically create and populate the in-memory database we need for our test. We've provided these files for you, but you'll need to amend them: `schema.sql` and `data.sql`.

**Note:** Providing `schema.sql` and `data.sql` is one of many ways Spring provides to easily initialize a database. To learn more, read the [Spring Framework documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization.using-basic-sql-scripts)

1. Edit `schema.sql`.

   As mentioned above, Spring Data will automatically configure a database for tests if we provide the correct file in the correct location.

   And we have! It's `src/main/resources/schema.sql`.

   But, it's currently disabled.

   Edit `src/main/resources/schema.sql` and remove the block-comment `/* ... */`.

   ```editor:open-file
   file: ~/exercises/src/main/resources/schema.sql
   ```

   ```sql
   CREATE TABLE cash_card
   (
      ID     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      AMOUNT NUMBER NOT NULL DEFAULT 0
   );
   ```

2. Understand `schema.sql`.

   A database schema is a "blueprint" for how data is stored in a database. We won't cover database schemas in depth here.

   Our database schema reflects the `CashCard` object that we understand, which contains an `id` and an `amount`.

3. Rerun the tests.

   **_Note:_** If the test output is too verbose, revert the change in `build.gradle` performed previously.

   Our tests no longer crash with a `500 INTERNAL_SERVER_ERROR`. However, now we get a `404 NOT_FOUND`

   ```dashboard:open-dashboard
   name: Terminal
   ```

   ```shell
   CashCardApplicationTests > shouldReturnACashCardWhenDataIsSaved() FAILED
    org.opentest4j.AssertionFailedError:
    expected: 200 OK
     but was: 404 NOT_FOUND
   ```

   Translation: Our repository can't find `CashCard` with `id` of `99`. So, why not?

   Although we've helped Spring Data create a test database by un-commenting `schema.sql`, it's still an _empty_ database.

   Let's go load some data!

4. Load test data from `data.sql`.

   Not only can Spring Data create our test database, it can also _load data into it_, which we can use in our tests.

   Similar to `schema.sql`, we've provided `src/test/resources/data.sql`, but its contents are also commented-out.

   Let's remove the block comments in `src/test/resources/data.sql`.

   ```editor:open-file
   file: ~/exercises/src/test/resources/data.sql
   ```

   ```sql
   INSERT INTO CASH_CARD(ID, AMOUNT) VALUES (99, 123.45);
   ```

   This SQL statement inserts a row into the `CASH_CARD` table with an `ID=99` and `AMOUNT=123.45`, which matches the values we expect in our tests.

5. Rerun the tests.

   They pass! Woo hoo!

   ```dashboard:open-dashboard
   name: Terminal
   ```

   ```shell
   [~/exercises] $ ./gradlew test
   ...
   BUILD SUCCESSFUL in 7s
   ```

Success! We're now using real data in our API.

### Learning Moment: `main` vs `test` resources

Have you noticed that `src/main/resources/schema.sql` and `src/test/resources/data.sql` are in different `resources` locations?

Can you guess why this is?

Remember that our Cash Card with ID `99` and Amount `123.45` is a fake, made-up Cash Card that we only want to use in our tests. We don't want our "real" or production system to load Cash Card `99` into the system... what would happen to the _real_ Cash Card `99`?

Spring has provided a powerful feature for us: it allows us to separate our test-only resources from our main resources when needed.

Our scenario here is a common example of this: our database schema is always the same, but our _data_ is not!

Thanks again, Spring!
